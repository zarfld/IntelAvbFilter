/*++
 *
 * The file contains the routines to create a device and handle ioctls
 *
-- */

#include "precomp.h"

#pragma NDIS_INIT_FUNCTION(IntelAvbFilterRegisterDevice)

_IRQL_requires_max_(PASSIVE_LEVEL)
NDIS_STATUS
IntelAvbFilterRegisterDevice(
    VOID
    )
{
    NDIS_STATUS            Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING         DeviceName;
    UNICODE_STRING         DeviceLinkUnicodeString;
    PDRIVER_DISPATCH       DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];
    NDIS_DEVICE_OBJECT_ATTRIBUTES   DeviceAttribute;
    PFILTER_DEVICE_EXTENSION        FilterDeviceExtension;
    PDRIVER_OBJECT                  DriverObject;
   
    DEBUGP(DL_ERROR, "!!! IntelAvbFilterRegisterDevice: ENTRY - Creating device interface\n");
   
    NdisZeroMemory(DispatchTable, (IRP_MJ_MAXIMUM_FUNCTION+1) * sizeof(PDRIVER_DISPATCH));
    
    DispatchTable[IRP_MJ_CREATE] = IntelAvbFilterDispatch;
    DispatchTable[IRP_MJ_CLEANUP] = IntelAvbFilterDispatch;
    DispatchTable[IRP_MJ_CLOSE] = IntelAvbFilterDispatch;
    DispatchTable[IRP_MJ_DEVICE_CONTROL] = IntelAvbFilterDeviceIoControl;
    
    
    NdisInitUnicodeString(&DeviceName, NTDEVICE_STRING);
    NdisInitUnicodeString(&DeviceLinkUnicodeString, LINKNAME_STRING);
    
    //
    // Create a device object and register our dispatch handlers
    //
    NdisZeroMemory(&DeviceAttribute, sizeof(NDIS_DEVICE_OBJECT_ATTRIBUTES));
    
    DeviceAttribute.Header.Type = NDIS_OBJECT_TYPE_DEVICE_OBJECT_ATTRIBUTES;
    DeviceAttribute.Header.Revision = NDIS_DEVICE_OBJECT_ATTRIBUTES_REVISION_1;
    DeviceAttribute.Header.Size = sizeof(NDIS_DEVICE_OBJECT_ATTRIBUTES);
    
    DeviceAttribute.DeviceName = &DeviceName;
    DeviceAttribute.SymbolicName = &DeviceLinkUnicodeString;
    DeviceAttribute.MajorFunctions = &DispatchTable[0];
    DeviceAttribute.ExtensionSize = sizeof(FILTER_DEVICE_EXTENSION);
    
    Status = NdisRegisterDeviceEx(
                FilterDriverHandle,
                &DeviceAttribute,
                &NdisDeviceObject,
                &NdisFilterDeviceHandle
                );
   
   
    if (Status == NDIS_STATUS_SUCCESS)
    {
        FilterDeviceExtension = (PFILTER_DEVICE_EXTENSION) NdisGetDeviceReservedExtension(NdisDeviceObject);
   
        FilterDeviceExtension->Signature = 'FTDR';
        FilterDeviceExtension->Handle = FilterDriverHandle;

        //
        // Workaround NDIS bug
        //
        DriverObject = (PDRIVER_OBJECT)FilterDriverObject;
        
        DEBUGP(DL_ERROR, "!!! Device interface created successfully: \\Device\\IntelAvbFilter -> \\\\.\\IntelAvbFilter\n");
    } else {
        DEBUGP(DL_ERROR, "!!! NdisRegisterDeviceEx FAILED: Status=0x%08X\n", Status);
    }
              
        
    DEBUGP(DL_ERROR, "!!! IntelAvbFilterRegisterDevice: EXIT Status=0x%08X\n", Status);
        
    return (Status);
        
}

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
IntelAvbFilterDeregisterDevice(
    VOID
    )

{
    if (NdisFilterDeviceHandle != NULL)
    {
        NdisDeregisterDeviceEx(NdisFilterDeviceHandle);
    }

    NdisFilterDeviceHandle = NULL;

}

_Use_decl_annotations_
NTSTATUS
IntelAvbFilterDispatch(
    PDEVICE_OBJECT       DeviceObject,
    PIRP                 Irp
    )
{
    PIO_STACK_LOCATION       IrpStack;
    NTSTATUS                 Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(DeviceObject);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    
    DEBUGP(DL_ERROR, "!!! IntelAvbFilterDispatch: MajorFunction=%u FileObject=%p\n",
           IrpStack->MajorFunction, IrpStack->FileObject);
    
    switch (IrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            DEBUGP(DL_ERROR, "!!! IRP_MJ_CREATE - Device opened by user-mode application\n");
            break;

        case IRP_MJ_CLEANUP:
            DEBUGP(DL_ERROR, "!!! IRP_MJ_CLEANUP - Handle being closed, cleaning up subscriptions for FileObject=%p\n", IrpStack->FileObject);
            AvbCleanupFileSubscriptions(IrpStack->FileObject);
            break;

        case IRP_MJ_CLOSE:
            DEBUGP(DL_ERROR, "!!! IRP_MJ_CLOSE\n");
            break;

        default:
            DEBUGP(DL_ERROR, "!!! Unknown MajorFunction=%u\n", IrpStack->MajorFunction);
            break;
    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

_Use_decl_annotations_                
NTSTATUS
IntelAvbFilterDeviceIoControl(
    PDEVICE_OBJECT        DeviceObject,
    PIRP                  Irp
    )
{
    PIO_STACK_LOCATION          IrpSp;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PFILTER_DEVICE_EXTENSION    FilterDeviceExtension;
    PUCHAR                      InputBuffer;
    PUCHAR                      OutputBuffer;
    ULONG                       InputBufferLength, OutputBufferLength;
    PLIST_ENTRY                 Link;
    PUCHAR                      pInfo;
    ULONG                       InfoLength = 0;
    PMS_FILTER                  pFilter = NULL;
    BOOLEAN                     bFalse = FALSE;


    UNREFERENCED_PARAMETER(DeviceObject);


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    
    // CRITICAL DEBUG: Log EVERY IOCTL that reaches this function
    DEBUGP(DL_ERROR, "!!! DEVICE.C ENTRY: IOCTL=0x%08X FileObject=%p\n", 
           IrpSp->Parameters.DeviceIoControl.IoControlCode,
           IrpSp->FileObject);
    
    // Implements #17 (REQ-NF-DIAG-REG-001: Registry Diagnostics)
    // DIAGNOSTIC: Write to registry to prove IOCTLs are reaching driver
    // This bypasses DebugView issues
    #if DBG
    {
        UNICODE_STRING keyPath = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\IntelAvb");
        OBJECT_ATTRIBUTES keyAttrs;
        HANDLE hKey = NULL;
        InitializeObjectAttributes(&keyAttrs, &keyPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
        
        NTSTATUS st = ZwCreateKey(&hKey, KEY_WRITE, &keyAttrs, 0, NULL, REG_OPTION_NON_VOLATILE, NULL);
        if (NT_SUCCESS(st)) {
            UNICODE_STRING valueName = RTL_CONSTANT_STRING(L"LastIOCTL");
            ULONG ioctlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
            ZwSetValueKey(hKey, &valueName, 0, REG_DWORD, &ioctlCode, sizeof(ioctlCode));
            ZwClose(hKey);
        }
    }
    #endif

    if (IrpSp->FileObject == NULL)
    {
        DEBUGP(DL_ERROR, "!!! DEVICE.C: FileObject is NULL - returning UNSUCCESSFUL\n");
        return(STATUS_UNSUCCESSFUL);
    }


    FilterDeviceExtension = (PFILTER_DEVICE_EXTENSION)NdisGetDeviceReservedExtension(DeviceObject);

    ASSERT(FilterDeviceExtension->Signature == 'FTDR');
    
    Irp->IoStatus.Information = 0;

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {

        case IOCTL_FILTER_RESTART_ALL:
            break;

        case IOCTL_FILTER_RESTART_ONE_INSTANCE:
            InputBuffer = OutputBuffer = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

            pFilter = filterFindFilterModule (InputBuffer, InputBufferLength);

            if (pFilter == NULL)
            {
                
                break;
            }

            NdisFRestartFilter(pFilter->FilterHandle);

            break;

        case IOCTL_FILTER_ENUERATE_ALL_INSTANCES:
            
            InputBuffer = OutputBuffer = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            
            
            pInfo = OutputBuffer;
            
            FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
            
            Link = FilterModuleList.Flink;
            
            while (Link != &FilterModuleList)
            {
                pFilter = CONTAINING_RECORD(Link, MS_FILTER, FilterModuleLink);

                
                InfoLength += (pFilter->FilterModuleName.Length + sizeof(USHORT));
                        
                if (InfoLength <= OutputBufferLength)
                {
                    *(PUSHORT)pInfo = pFilter->FilterModuleName.Length;
                    NdisMoveMemory(pInfo + sizeof(USHORT), 
                                   (PUCHAR)(pFilter->FilterModuleName.Buffer),
                                   pFilter->FilterModuleName.Length);
                            

                    pInfo += (pFilter->FilterModuleName.Length + sizeof(USHORT));
                }
                
                Link = Link->Flink;
            }
               

            FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
            if (InfoLength <= OutputBufferLength)
            {
       
                Status = NDIS_STATUS_SUCCESS;
            }
            //
            // Buffer is small
            //
            else
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;

        // AVB IOCTLs - Handle through AVB integration layer
        case IOCTL_AVB_GET_VERSION:       // Implements #64 (REQ-F-IOCTL-VERSIONING-001) - MUST be first!
        case IOCTL_AVB_INIT_DEVICE:
        case IOCTL_AVB_GET_DEVICE_INFO:
#ifndef NDEBUG
        case IOCTL_AVB_READ_REGISTER:
        case IOCTL_AVB_WRITE_REGISTER:
#endif
        case IOCTL_AVB_GET_TIMESTAMP:
        case IOCTL_AVB_SET_TIMESTAMP:
        case IOCTL_AVB_SETUP_TAS:
        case IOCTL_AVB_SETUP_FP:
        case IOCTL_AVB_SETUP_PTM:
        case IOCTL_AVB_MDIO_READ:
        case IOCTL_AVB_MDIO_WRITE:
        case IOCTL_AVB_GET_HW_STATE:
        case IOCTL_AVB_ADJUST_FREQUENCY:
        case IOCTL_AVB_GET_CLOCK_CONFIG:  // Implements #4 (BUG: IOCTL_AVB_GET_CLOCK_CONFIG Not Working)
        case IOCTL_AVB_SET_HW_TIMESTAMPING:
        case IOCTL_AVB_SET_RX_TIMESTAMP:
        case IOCTL_AVB_SET_QUEUE_TIMESTAMP:
        case IOCTL_AVB_SET_TARGET_TIME:
        case IOCTL_AVB_GET_AUX_TIMESTAMP:
        case IOCTL_AVB_TS_SUBSCRIBE:      // Implements #13 (REQ-F-TS-SUB-001)
        case IOCTL_AVB_TS_RING_MAP:       // Implements #13 (REQ-F-TS-SUB-001)
        {
            DEBUGP(DL_ERROR, "!!! DEVICE.C: AVB IOCTL CASE HIT: IOCTL=0x%08X\n", 
                   IrpSp->Parameters.DeviceIoControl.IoControlCode);
            
            // CRITICAL FIX: If g_AvbContext is set (from OPEN_ADAPTER), use it directly
            // This ensures multi-adapter scenarios work correctly
            PAVB_DEVICE_CONTEXT targetContext = g_AvbContext;
            
            if (targetContext != NULL) {
                DEBUGP(DL_ERROR, "!!! DEVICE.C: Using global context VID=0x%04X DID=0x%04X state=%s\n",
                       targetContext->intel_device.pci_vendor_id, targetContext->intel_device.pci_device_id,
                       AvbHwStateName(targetContext->hw_state));
                pFilter = targetContext->filter_instance;
            } else {
                // Fall back to searching for any Intel filter (single-adapter mode)
                DEBUGP(DL_INFO, "!!! DEVICE.C: No global context, searching for Intel filter\n");
                pFilter = AvbFindIntelFilterModule();
                DEBUGP(DL_ERROR, "!!! DEVICE.C: Found filter=%p\n", pFilter);
                
                if (pFilter) {
                    DEBUGP(DL_ERROR, "!!! DEVICE.C: Filter Name: %wZ\n", &pFilter->MiniportFriendlyName);
                    if (pFilter->AvbContext) {
                        targetContext = (PAVB_DEVICE_CONTEXT)pFilter->AvbContext;
                        DEBUGP(DL_ERROR, "!!! DEVICE.C: Context VID=0x%04X DID=0x%04X state=%s\n",
                               targetContext->intel_device.pci_vendor_id, targetContext->intel_device.pci_device_id,
                               AvbHwStateName(targetContext->hw_state));
                    }
                }

                // If not found, iterate all filter instances and lazily initialize until one succeeds
                if (pFilter == NULL)
                {
                    DEBUGP(DL_INFO, "?? No initialized Intel filter found, attempting lazy initialization\n");
                    
                    FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
                    Link = FilterModuleList.Flink;
                    
                    while (Link != &FilterModuleList)
                    {
                        PMS_FILTER cand = CONTAINING_RECORD(Link, MS_FILTER, FilterModuleLink);
                        Link = Link->Flink; // Move to next before releasing lock
                        
                        FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
                        
                        DEBUGP(DL_INFO, "?? Checking candidate filter: %wZ\n", &cand->MiniportFriendlyName);
                        
                        // Check if this filter might be an Intel adapter
                        if (cand->AvbContext == NULL)
                        {
                            USHORT ven = 0, dev = 0;
                            if (AvbIsSupportedIntelController(cand, &ven, &dev))
                            {
                                DEBUGP(DL_INFO, "? Found uninitialized Intel adapter %wZ (VID=0x%04X DID=0x%04X), initializing AVB context\n",
                                       &cand->MiniportFriendlyName, ven, dev);
                                

                                NTSTATUS initSt = AvbInitializeDevice(cand, (PAVB_DEVICE_CONTEXT*)&cand->AvbContext);
                                if (NT_SUCCESS(initSt) && cand->AvbContext != NULL)
                                {
                                    DEBUGP(DL_INFO, "? Successfully initialized AVB context for %wZ\n", 
                                           &cand->MiniportFriendlyName);
                                    pFilter = cand;
                                    targetContext = (PAVB_DEVICE_CONTEXT)cand->AvbContext;
                                    break;
                                }
                                else
                                {
                                    DEBUGP(DL_WARN, "? Failed to initialize AVB context for %wZ: 0x%x\n", 
                                           &cand->MiniportFriendlyName, initSt);
                                }
                            } else {
                                DEBUGP(DL_INFO, "   - Not supported Intel controller\n");
                            }
                        } else {
                            DEBUGP(DL_INFO, "   - Already has AVB context\n");
                        }
                        
                        FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
                    }
                    
                    FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
                }
            }

            // DIAGNOSTIC: Write context status BEFORE the NULL check
            #if DBG
            {
                OBJECT_ATTRIBUTES keyAttrs2;
                HANDLE hKey2;
                NTSTATUS st2;
                ULONG contextStatus;
                UNICODE_STRING keyPath2;
                UNICODE_STRING valueName2;
                
                RtlInitUnicodeString(&keyPath2, L"\\Registry\\Machine\\Software\\IntelAvb");
                hKey2 = NULL;
                InitializeObjectAttributes(&keyAttrs2, &keyPath2, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
                
                st2 = ZwCreateKey(&hKey2, KEY_WRITE, &keyAttrs2, 0, NULL, REG_OPTION_NON_VOLATILE, NULL);
                if (NT_SUCCESS(st2)) {
                    RtlInitUnicodeString(&valueName2, L"TargetContextNullCheck");
                    contextStatus = (targetContext == NULL) ? 0 : 1;
                    ZwSetValueKey(hKey2, &valueName2, 0, REG_DWORD, &contextStatus, sizeof(contextStatus));
                    ZwClose(hKey2);
                }
            }
            #endif

            if (targetContext != NULL) {
                DEBUGP(DL_ERROR, "!!! BEFORE AvbHandleDeviceIoControl: filter=%p context=%p IOCTL=0x%08X\n", 
                       pFilter, targetContext, IrpSp->Parameters.DeviceIoControl.IoControlCode);
                
                // DIAGNOSTIC: Write pre-handler state to registry
                #if DBG
                {
                    UNICODE_STRING keyPath = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\IntelAvb");
                    OBJECT_ATTRIBUTES keyAttrs;
                    HANDLE hKey = NULL;
                    InitializeObjectAttributes(&keyAttrs, &keyPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
                    
                    NTSTATUS st = ZwCreateKey(&hKey, KEY_WRITE, &keyAttrs, 0, NULL, REG_OPTION_NON_VOLATILE, NULL);
                    if (NT_SUCCESS(st)) {
                        UNICODE_STRING valueName = RTL_CONSTANT_STRING(L"StepReached");
                        ULONG value = 1; // Step 1: Before handler
                        ZwSetValueKey(hKey, &valueName, 0, REG_DWORD, &value, sizeof(value));
                        ZwClose(hKey);
                    }
                }
                #endif
                
                Status = AvbHandleDeviceIoControl(targetContext, Irp);
                InfoLength = (ULONG)Irp->IoStatus.Information;
                
                // DIAGNOSTIC: Write post-handler state to registry
                #if DBG
                {
                    OBJECT_ATTRIBUTES keyAttrs;
                    HANDLE hKey;
                    NTSTATUS st;
                    ULONG value;
                    ULONG irpInfo;
                    UNICODE_STRING keyPath;
                    UNICODE_STRING valueName;
                    
                    RtlInitUnicodeString(&keyPath, L"\\Registry\\Machine\\Software\\IntelAvb");
                    hKey = NULL;
                    InitializeObjectAttributes(&keyAttrs, &keyPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
                    
                    st = ZwCreateKey(&hKey, KEY_WRITE, &keyAttrs, 0, NULL, REG_OPTION_NON_VOLATILE, NULL);
                    if (NT_SUCCESS(st)) {
                        RtlInitUnicodeString(&valueName, L"StepReached");
                        value = 2;
                        ZwSetValueKey(hKey, &valueName, 0, REG_DWORD, &value, sizeof(value));
                        
                        RtlInitUnicodeString(&valueName, L"PostHandlerStatus");
                        ZwSetValueKey(hKey, &valueName, 0, REG_DWORD, &Status, sizeof(Status));
                        
                        RtlInitUnicodeString(&valueName, L"PostHandlerInfoLength");
                        ZwSetValueKey(hKey, &valueName, 0, REG_DWORD, &InfoLength, sizeof(InfoLength));
                        
                        irpInfo = (ULONG)Irp->IoStatus.Information;
                        RtlInitUnicodeString(&valueName, L"PostHandlerIrpInfo");
                        ZwSetValueKey(hKey, &valueName, 0, REG_DWORD, &irpInfo, sizeof(irpInfo));
                        
                        ZwClose(hKey);
                    }
                }
                #endif
                
                DEBUGP(DL_ERROR, "!!! AFTER AvbHandleDeviceIoControl: Status=0x%x, InfoLength=%lu\n", 
                       Status, InfoLength);
            } else {
                DEBUGP(DL_ERROR, "? No Intel filter found or AVB context not initialized\n");
                Status = STATUS_DEVICE_NOT_READY;
            }
            break;
        }

        // Implements: #15 (REQ-F-MULTIDEV-001.1: Adapter Enumeration)
        case IOCTL_AVB_ENUM_ADAPTERS:
        {
            DEBUGP(DL_TRACE, "IntelAvbFilterDeviceIoControl: ENUM_ADAPTERS (multi-adapter mode)\n");
            
            // ENUM_ADAPTERS needs special handling for multi-adapter support
            // Count ALL Intel adapters, not just find one
            
            InputBuffer = OutputBuffer = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            
            if (OutputBufferLength < sizeof(AVB_ENUM_REQUEST)) {
                DEBUGP(DL_ERROR, "ENUM_ADAPTERS: Buffer too small (%lu < %lu)\n", 
                       OutputBufferLength, (ULONG)sizeof(AVB_ENUM_REQUEST));
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
            
            PAVB_ENUM_REQUEST req = (PAVB_ENUM_REQUEST)OutputBuffer;
            ULONG requestedIndex = req->index; // Input: which adapter index to query
            ULONG adapterCount = 0;
            BOOLEAN foundRequestedAdapter = FALSE;
            
            // Initialize response
            req->count = 0;
            req->vendor_id = 0;
            req->device_id = 0;
            req->capabilities = 0;
            req->status = NDIS_STATUS_SUCCESS;
            
            DEBUGP(DL_INFO, "ENUM_ADAPTERS: Scanning for adapters, requested index=%lu\n", requestedIndex);
            
            // Scan ALL filter instances to count Intel adapters
            FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
            Link = FilterModuleList.Flink;
            
            while (Link != &FilterModuleList)
            {
                PMS_FILTER cand = CONTAINING_RECORD(Link, MS_FILTER, FilterModuleLink);
                Link = Link->Flink; // Move to next
                
                FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
                
                // Check if this is a supported Intel adapter
                USHORT ven = 0, dev = 0;
                if (AvbIsSupportedIntelController(cand, &ven, &dev))
                {
                    DEBUGP(DL_INFO, "ENUM_ADAPTERS: Found Intel adapter #%lu: %wZ (VID=0x%04X, DID=0x%04X)\n",
                           adapterCount, &cand->MiniportFriendlyName, ven, dev);
                    
                    // If this is the requested adapter index, populate the response
                    if (adapterCount == requestedIndex)
                    {
                        req->vendor_id = ven;
                        req->device_id = dev;
                        
                        // Initialize AVB context if needed
                        if (cand->AvbContext == NULL)
                        {
                            DEBUGP(DL_INFO, "ENUM_ADAPTERS: Initializing AVB context for requested adapter #%lu\n", adapterCount);
                            NTSTATUS initSt = AvbInitializeDevice(cand, (PAVB_DEVICE_CONTEXT*)&cand->AvbContext);
                            if (NT_SUCCESS(initSt) && cand->AvbContext != NULL)
                            {
                                DEBUGP(DL_INFO, "ENUM_ADAPTERS: Successfully initialized AVB context for requested adapter #%lu\n", 
                                       adapterCount);
                            }
                            else
                            {
                                DEBUGP(DL_WARN, "ENUM_ADAPTERS: Failed to initialize AVB context for requested adapter #%lu: 0x%x\n", 
                                       adapterCount, initSt);
                                // Still count it but with limited capabilities
                                req->capabilities = 0;
                            }
                        }
                        
                        // Get capabilities from already-initialized context
                        if (cand->AvbContext != NULL)
                        {
                            PAVB_DEVICE_CONTEXT ctx = (PAVB_DEVICE_CONTEXT)cand->AvbContext;
                            
                            DEBUGP(DL_FATAL, "!!! DIAG: ENUM_ADAPTERS - Reading from context %p:\n", ctx);
                            DEBUGP(DL_FATAL, "    ctx->intel_device.pci_vendor_id=0x%04X\n", ctx->intel_device.pci_vendor_id);
                            DEBUGP(DL_FATAL, "    ctx->intel_device.pci_device_id=0x%04X\n", ctx->intel_device.pci_device_id);
                            DEBUGP(DL_FATAL, "    ctx->intel_device.device_type=%d\n", ctx->intel_device.device_type);
                            DEBUGP(DL_FATAL, "    ctx->intel_device.capabilities=0x%08X\n", ctx->intel_device.capabilities);
                            DEBUGP(DL_FATAL, "    ctx->hw_state=%d (%s)\n", ctx->hw_state, AvbHwStateName(ctx->hw_state));
                            
                            // CRITICAL FIX: Don't call intel_init() here - it was already called during
                            // AvbBringUpHardware from IOCTL_AVB_INIT_DEVICE. Just read the cached capabilities.
                            // Calling intel_init() repeatedly resets capabilities to 0 when it fails.
                            req->capabilities = ctx->intel_device.capabilities;
                            ctx->hw_access_enabled = (ctx->hw_state >= AVB_HW_BAR_MAPPED);
                            
                            DEBUGP(DL_INFO, "ENUM_ADAPTERS: Adapter #%lu capabilities=0x%08X (hw_state=%d)\n", 
                                   adapterCount, req->capabilities, ctx->hw_state);
                            DEBUGP(DL_FATAL, "!!! DIAG: ENUM_ADAPTERS - Writing to response buffer: req->capabilities=0x%08X\n", 
                                   req->capabilities);
                        }
                        else
                        {
                            DEBUGP(DL_WARN, "ENUM_ADAPTERS: Adapter #%lu has no AVB context\n", adapterCount);
                            req->capabilities = 0;
                        }
                        
                        foundRequestedAdapter = TRUE;
                    }
                    
                    adapterCount++;
                }
                
                FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
            }
            
            FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
            
            // Set total count
            req->count = adapterCount;
            
            if (adapterCount == 0)
            {
                DEBUGP(DL_WARN, "ENUM_ADAPTERS: No Intel adapters found with active bindings\n");
                Status = STATUS_NO_SUCH_DEVICE;
            }
            else if (requestedIndex >= adapterCount)
            {
                DEBUGP(DL_WARN, "ENUM_ADAPTERS: Requested index %lu >= adapter count %lu\n", 
                       requestedIndex, adapterCount);
                Status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                DEBUGP(DL_INFO, "ENUM_ADAPTERS: Success - Total adapters=%lu, returned adapter #%lu (VID=0x%04X, DID=0x%04X, caps=0x%08X)\n",
                       adapterCount, requestedIndex, req->vendor_id, req->device_id, req->capabilities);
                DEBUGP(DL_FATAL, "!!! DIAG: ENUM_ADAPTERS - FINAL response buffer before IRP completion:\n");
                DEBUGP(DL_FATAL, "    req=%p, req->count=%u, req->index=%u\n", req, req->count, req->index);
                DEBUGP(DL_FATAL, "    req->vendor_id=0x%04X, req->device_id=0x%04X\n", req->vendor_id, req->device_id);
                DEBUGP(DL_FATAL, "    req->capabilities=0x%08X\n", req->capabilities);
                DEBUGP(DL_FATAL, "    InfoLength=%lu, sizeof(AVB_ENUM_REQUEST)=%lu\n", 
                       InfoLength, (ULONG)sizeof(AVB_ENUM_REQUEST));
                Status = NDIS_STATUS_SUCCESS;
                InfoLength = sizeof(AVB_ENUM_REQUEST);
            }
            
            break;
        }
             
        // Implements: #15 (REQ-F-MULTIDEV-001.2: Adapter Selection)
        case IOCTL_AVB_OPEN_ADAPTER:
        {
            DEBUGP(DL_TRACE, "IntelAvbFilterDeviceIoControl: OPEN_ADAPTER (multi-adapter mode)\n");
            
            InputBuffer = OutputBuffer = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            
            if (InputBufferLength < sizeof(AVB_OPEN_REQUEST) || OutputBufferLength < sizeof(AVB_OPEN_REQUEST)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
            
            PAVB_OPEN_REQUEST req = (PAVB_OPEN_REQUEST)OutputBuffer;
            PMS_FILTER targetFilter = NULL;
            
            FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
            Link = FilterModuleList.Flink;
            
            while (Link != &FilterModuleList)
            {
                PMS_FILTER cand = CONTAINING_RECORD(Link, MS_FILTER, FilterModuleLink);
                Link = Link->Flink;
                
                FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
                
                USHORT ven = 0, dev = 0;
                if (AvbIsSupportedIntelController(cand, &ven, &dev) && 
                    ven == req->vendor_id && dev == req->device_id)
                {
                    targetFilter = cand;
                    break;
                }
                
                FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
            }
            
            FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
            
            if (targetFilter == NULL) {
                req->status = (avb_u32)NDIS_STATUS_FAILURE;
                Status = STATUS_NO_SUCH_DEVICE;
            } else {
                if (targetFilter->AvbContext == NULL) {
                    AvbInitializeDevice(targetFilter, (PAVB_DEVICE_CONTEXT*)&targetFilter->AvbContext);
                }
                
                if (targetFilter->AvbContext != NULL) {
                    Status = AvbHandleDeviceIoControl((PAVB_DEVICE_CONTEXT)targetFilter->AvbContext, Irp);
                    InfoLength = (ULONG)Irp->IoStatus.Information;
                } else {
                    req->status = (avb_u32)NDIS_STATUS_FAILURE;
                    Status = STATUS_UNSUCCESSFUL;
                }
            }


            if (Status != STATUS_PENDING) {
                InfoLength = sizeof(AVB_OPEN_REQUEST);
            }
            break;
        }

        default:
            break;
    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = InfoLength;
    
    // DIAGNOSTIC: Write final IRP completion values to registry
    #if DBG
    {
        OBJECT_ATTRIBUTES keyAttrs3;
        HANDLE hKey3;
        NTSTATUS st3;
        UNICODE_STRING keyPath3;
        UNICODE_STRING valueName3;
        
        RtlInitUnicodeString(&keyPath3, L"\\Registry\\Machine\\Software\\IntelAvb");
        hKey3 = NULL;
        InitializeObjectAttributes(&keyAttrs3, &keyPath3, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
        
        st3 = ZwCreateKey(&hKey3, KEY_WRITE, &keyAttrs3, 0, NULL, REG_OPTION_NON_VOLATILE, NULL);
        if (NT_SUCCESS(st3)) {
            RtlInitUnicodeString(&valueName3, L"FinalIrpStatus");
            ZwSetValueKey(hKey3, &valueName3, 0, REG_DWORD, &Status, sizeof(Status));
            
            RtlInitUnicodeString(&valueName3, L"FinalInfoLength");
            ZwSetValueKey(hKey3, &valueName3, 0, REG_DWORD, &InfoLength, sizeof(InfoLength));
            
            ZwClose(hKey3);
        }
    }
    #endif

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
            

}


_IRQL_requires_max_(DISPATCH_LEVEL)
PMS_FILTER
filterFindFilterModule(
    _In_reads_bytes_(BufferLength)
         PUCHAR                   Buffer,
    _In_ ULONG                    BufferLength
    )
{

   PMS_FILTER              pFilter;
   PLIST_ENTRY             Link;
   BOOLEAN                  bFalse = FALSE;
   
   FILTER_ACQUIRE_LOCK(&FilterListLock, bFalse);
               
   Link = FilterModuleList.Flink;
               
   while (Link != &FilterModuleList)
   {
       pFilter = CONTAINING_RECORD(Link, MS_FILTER, FilterModuleLink);

       if (BufferLength >= pFilter->FilterModuleName.Length)
       {
           if (NdisEqualMemory(Buffer, pFilter->FilterModuleName.Buffer, pFilter->FilterModuleName.Length))
           {
               FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
               return pFilter;
           }
       }
           
       Link = Link->Flink;
   }
   
   FILTER_RELEASE_LOCK(&FilterListLock, bFalse);
   return NULL;
}















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































